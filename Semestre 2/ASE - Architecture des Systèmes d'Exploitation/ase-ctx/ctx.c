#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

#include "ctx.h"
#include "hardware.h"



void init_ctx(struct ctx_s* ctx, int stack_size, func_t f, void* f_args)
{
    irq_disable();

    void* stack = malloc(stack_size);

    if(stack == NULL)
    {
        irq_enable();
        assert(stack != NULL);
    }

    ctx->sp     = stack + stack_size - sizeof(void*);
    ctx->bp     = ctx->sp;
    ctx->stack  = stack;
    ctx->f      = f;
    ctx->f_args = f_args;
    ctx->etat   = INIT;
    ctx->magic  = MAGIC;

    irq_enable();
}



void switch_to_ctx(struct ctx_s* ctx)
{
    irq_disable();

    /* on sauvegarde le contexte courant */
    if(ctx_courant != NULL)
    {
        asm("mov %%rsp, %0" "\n\t" "mov %%rbp, %1"
            : "=r"(ctx_courant->sp),
              "=r"(ctx_courant->bp));
    }

    /* on vérifie l'intégrité des données avant de switcher */
    if(ctx->magic != MAGIC)
    {
        irq_enable();
        assert(ctx->magic == MAGIC);
    }
    ctx_courant = ctx;

    /* on continue le contexte en argument */
    asm("mov %0, %%rsp" "\n\t" "mov %1, %%rbp"
        :
        : "r"(ctx->sp),
          "r"(ctx->bp));
    
    /* on met à jour  */
    if(ctx_courant->etat == INIT)
    {
        ctx_courant->etat = ACTIF;
        ctx_courant->f(ctx_courant->f_args);
        ctx_courant->etat = TERMINE;
        yield();
    }

    irq_enable();
}



void create_ctx(int stack_size, func_t f, void* f_args)
{
    irq_disable();

    struct ctx_s* ctx = malloc(sizeof(struct ctx_s));
    
    if(ctx == NULL)
    {
        irq_enable();
        assert(ctx != NULL);
    }

    init_ctx(ctx, stack_size, f, f_args);

    if(ctx_anneau == NULL)
    {
        ctx->suivant = ctx;
        ctx_anneau = ctx;
    }
    else
    {
        ctx->suivant = ctx_anneau->suivant;
        ctx_anneau->suivant = ctx;
    }

    irq_enable();
}



void yield()
{
    irq_disable();

    if(ctx_anneau == NULL)
    {
        irq_enable();
        assert(ctx_anneau != NULL);
    }

    struct ctx_s* next;

    if(ctx_courant != NULL)
    {
        while(ctx_courant->suivant->etat == TERMINE)
        {
            free(ctx_courant->suivant->stack);
            ctx_courant->suivant = ctx_courant->suivant->suivant;
            free(ctx_courant->suivant);
        
            assert(ctx_courant->suivant != ctx_courant);
        }

        next = ctx_courant->suivant;
    }
    else
        next = ctx_anneau;

    irq_enable();
    switch_to_ctx(next);
}



void start_sched()
{
    int i;

    assert(init_hardware("hardware.ini") != 0);

    for(i=0; i<16; i++)
    {
        IRQVECTOR[i] = NULL;
    }

    IRQVECTOR[TIMER_IRQ] = yield;
    _out(TIMER_PARAM, 0xFF);
    _out(TIMER_ALARM, 0xFF);
}



int main()
{
    // init_ctx(&ctx_ping, 16384, f_ping, NULL);
    // init_ctx(&ctx_pong, 16384, f_pong, NULL);
    // switch_to_ctx(&ctx_ping);

    create_ctx(16384, f_ping, NULL);
    create_ctx(16384, f_pong, NULL);

    start_sched();

    yield();

    exit(EXIT_SUCCESS);
}



void f_ping()
{
    while(1)
    {
        printf("A");
        // switch_to_ctx(&ctx_pong);
        yield();
        printf("B");
        // switch_to_ctx(&ctx_pong);
        yield();
        printf("C");
        // switch_to_ctx(&ctx_pong);
        yield();
    }
}



void f_pong()
{
    while(1)
    {
        printf("1");
        // switch_to_ctx(&ctx_ping);
        yield();
        printf("2");
        // switch_to_ctx(&ctx_ping);
        yield();
    }
}



void irq_disable()
{
    _mask(15);
}



void irq_enable()
{
    _mask(1); // doit autoriser toutes les interruptions
}



/* ordre des contextes 1 -> 5 -> 4 -> 3 -> 2 */