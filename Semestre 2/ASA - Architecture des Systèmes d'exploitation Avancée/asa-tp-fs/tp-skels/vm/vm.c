/* ------------------------------
   $Id: vm-skel.c,v 1.1 2002/10/21 07:16:29 marquet Exp $
   ------------------------------------------------------------

   Volume manager skeleton.
   Philippe Marquet, october 2002

   1- you must complete the NYI (not yet implemented) functions
   2- you may add commands (format, etc.)
   
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mbr.h"
#include "drive.h"
#include "../../libhw/include/hardware.h"



/* ------------------------------
   command list
   ------------------------------------------------------------*/

struct _cmd
{
    char *name;
    void (*fun) (struct _cmd *c);
    char *comment;
};



static void list(struct _cmd *c);
static void  new(struct _cmd *c);
static void  del(struct _cmd *c);
static void help(struct _cmd *c);
static void save(struct _cmd *c);
static void quit(struct _cmd *c);
static void  xit(struct _cmd *c);
static void none(struct _cmd *c);



static struct _cmd commands [] =
{
    {"list"   , list   , "display the partition table"},
    {"new"    , new    , "create a new partition"     },
    {"del"    , del    , "delete a partition"         },
    {"save"   , save   , "save the MBR"               },
    {"quit"   , quit   , "save the MBR and quit"      },
    {"exit"   , xit    , "exit (without saving)"      },
    {"help"   , help   , "display this help"          },
    {     0   , none   , "unknown command, try help"  }
};



/* ------------------------------
   dialog and execute 
   ------------------------------------------------------------*/

static void execute(const char *name)
{
    struct _cmd *c = commands; 
  
    while(c->name && strcmp (name, c->name))
    {
	    c++;
    }

    (*c->fun)(c);
}

static void loop(void)
{
    char name[64];
    
    while (printf("> "), scanf("%62s", name) == 1)
    {
	    execute(name) ;
    }
}



/* ------------------------------
   command execution 
   ------------------------------------------------------------*/

static void list(struct _cmd *c)
{
    unsigned int i;

    printf("%.*s %.*s %.*s %.*s %.*s\n",
           6, "Volume" ,
           5, "Start"  ,
           3, "End"    ,
           7, "Sectors",
           5, "Size"   );

    for(i=0; i<mbr.nvol; i++)
    {
        unsigned int volume  = i;
        unsigned int start   = mbr.volumes[i].start;
        unsigned int end     = mbr.volumes[i].start + mbr.volumes[i].size - 1;
        unsigned int sectors = mbr.volumes[i].size;
        unsigned int size    = mbr.volumes[i].size * HDA_SECTORSIZE;

        printf("%.*d %.*d %.*d %.*d %.*d\n",
               6, volume ,
               5, start  ,
               3, end    ,
               7, sectors,
               5, size   );
    }
}

static void new(struct _cmd *c)
{
    unsigned int i;
    struct volume volume;

    if(mbr.nvol == MAX_VOL)
        printf("The disk cannot hold more volumes.\n");
    else
    {
        /*  Prompt for the volume starting sector  */

        printf("Enter a starting sector number between 0 and %d : ", (HDA_MAXCYLINDER*HDA_MAXSECTOR)-1);
        scanf("%d", &volume.start);
        fflush(stdout);

        /*  Check for those potential errors : 
         *  - if the volume overflows from the disk
         *  - if the volume encroaches on another
         */

        if(0>volume.start || volume.start>=(HDA_MAXCYLINDER*HDA_MAXSECTOR))
        {
            printf("The starting sector does not exist.\n");
            return;
        }

        for(i=0; i<mbr.nvol; i++)
        {
            unsigned int start_of_a_volume = mbr.volumes[i].start;
            unsigned int end_of_a_volume = mbr.volumes[i].start + mbr.volumes[i].size - 1;

            if(start_of_a_volume<=volume.start && volume.start<=end_of_a_volume)
            {
                printf("The starting sector encroaches on a volume.\n");
                return;
            }
        }

        /*  Prompt for the volume size  */

        printf("Enter a size between 0 and %d : ", (HDA_MAXCYLINDER*HDA_MAXSECTOR)-1);
        scanf("%d", &volume.size);
        fflush(stdout);

        /*  Check for those potential errors : 
         *  - if the volume overflows from the disk
         *  - if the volume encroaches on another
         *  - if the volume contains another
         */

        if(volume.start+volume.size > (HDA_MAXCYLINDER*HDA_MAXSECTOR)-1)
        {
            printf("The volume overflows from the disk.\n");
            return;
        }

        for(i=0; i<mbr.nvol; i++)
        {
            unsigned int start_of_a_volume = mbr.volumes[i].start;
            unsigned int end_of_a_volume = mbr.volumes[i].start + mbr.volumes[i].size - 1;

            if(start_of_a_volume<=(volume.start+volume.size) && (volume.start+volume.size)<=end_of_a_volume)
            {
                printf("The ending sector encroaches on a volume.\n");
                return;
            }

            if(start_of_a_volume>=volume.start && (volume.start+volume.size)>=end_of_a_volume)
            {
                printf("The volume contains another volume.\n");
                return;
            }
        }

        /*  Create the new volume  */

        mbr.volumes[mbr.nvol] = volume;
        mbr.nvol++;

        printf("The volume has been created.\n");
    }
}

static void del(struct _cmd *c)
{
    unsigned int i;

    if(mbr.nvol == 0)
    {
        printf("There is no deletable volume.\n");
        return;
    }

    printf("Enter a volume number between 0 and %d : ", mbr.nvol-1);
    scanf("%d", &i);
    fflush(stdout);

    if(0>i || i>=MAX_VOL)
        printf("The volume does not exist.\n");
    else
    {
        format_vol(i);

        for(; i<mbr.nvol-1; i++)
        {
            mbr.volumes[i] = mbr.volumes[i+1];
        }

        mbr.nvol--;

        printf("The volume has been deleted.\n");
    }
}

static void save(struct _cmd *c)
{
    write_mbr();
}

static void quit(struct _cmd *c)
{
    save(c);
    exit(EXIT_SUCCESS);
}

static void do_xit()
{
    exit(EXIT_SUCCESS);
}

static void xit(struct _cmd *dummy)
{
    do_xit(); 
}

static void help(struct _cmd *dummy)
{
    struct _cmd *c = commands;
  
    for(; c->name; c++) 
	{
        printf("%s\t-- %s\n", c->name, c->comment);
    }
}

static void none(struct _cmd *c)
{
    printf("%s\n", c->comment) ;
}



int main(int argc, char **argv)
{
    init_master();
    
    read_mbr();

    /* dialog with user */ 
    loop();

    /* abnormal end of dialog (cause EOF for xample) */
    do_xit();
    
    return EXIT_SUCCESS;
}
