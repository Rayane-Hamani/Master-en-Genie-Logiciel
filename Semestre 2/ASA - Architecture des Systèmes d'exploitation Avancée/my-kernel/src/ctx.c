#include "assert.h"
#include "ctx.h"



#define SAVE_CTX(esp, ebp) {  \
  asm("mov %%esp, %0" "\n\t"  \
      "mov %%ebp, %1" "\n\t"  \
      : "=r"(esp),            \
        "=r"(ebp)); }

#define LOAD_CTX(esp, ebp) {  \
  asm("mov %0, %%esp" "\n\t"  \
      "mov %1, %%ebp" "\n\t"  \
      :                       \
      : "r"(esp),             \
        "r"(ebp)); }



static ctx_t contexts[MAX_CTX_NUM];
static ctx_t* first_free_ctx;
static ctx_t* current_ctx;

static ctx_lst_t ctx_lst;



void init_contexts()
{
  /* init the list of contexts */
  ctx_lst_init(&ctx_lst);

  /* init the first contexts */
  for(unsigned int i=0; i<MAX_CTX_NUM-1; i++)
  {
    contexts[i].state = UNDEFINED;
    contexts[i].next  = &contexts[i+1];
    contexts[i].prev  = NULL;
  }

  /* init the last context */
  contexts[MAX_CTX_NUM-1].state = UNDEFINED;
  contexts[MAX_CTX_NUM-1].next  = NULL;
  contexts[MAX_CTX_NUM-1].prev  = NULL;

  /* init the first free context and the current context */
  first_free_ctx = &contexts[0];
  current_ctx    = NULL;
}



ctx_t* alloc_context(func_t f, void* f_args)
{
  if(first_free_ctx == NULL)
    return NULL;

  ctx_t* ctx = first_free_ctx;

  ctx->esp    = ctx->stack + CTX_STACK_SIZE - sizeof(unsigned char);
  ctx->ebp    = ctx->esp;
  ctx->f      = f;
  ctx->f_args = f_args;
  ctx->state  = NEWBORN;
  ctx->magic  = CTX_MAGIC;

  first_free_ctx = ctx->next;
  ctx_lst_insert(&ctx_lst, ctx);

  return ctx;
}



void free_context(ctx_t* ctx)
{
  /* nullify the context's attributes */
  ctx->esp    = NULL;
  ctx->ebp    = NULL;
  for(unsigned int i=0; i<CTX_STACK_SIZE; i++)
  {
    ctx->stack[i] = NULL;
  }
  ctx->f      = NULL;
  ctx->f_args = NULL;
  ctx->state  = UNDEFINED;
  ctx->magic  = NULL;
  ctx->next   = NULL;
  ctx->prev   = NULL;

  /* remove the context from the list of contexts */
  ctx_lst_remove(&ctx_lst, ctx);

  /* keep a trace of the freed context for a potential re-use */
  ctx->next = first_free_ctx;
  first_free_ctx = ctx;
}



void switch_to(ctx_t* ctx)
{
  /* save the current context */
  if(current_ctx != NULL)
    SAVE_CTX(current_ctx->esp, current_ctx->ebp);

  /* check the integrity of the data before the switch */
  assert(ctx->magic == CTX_MAGIC);

  current_ctx = ctx;

  /* load the context to switch to */
  LOAD_CTX(current_ctx->esp, current_ctx->ebp);
    
  /* update it */
  if(current_ctx->state == NEWBORN)
  {
    current_ctx->state = RUNNABLE;
    __asm volatile("cli");
    current_ctx->f(current_ctx->f_args);
    __asm volatile("sti");
    current_ctx->state = TERMINATED;
    yield();
  }
}



void yield()
{
  /* check if there is a context before getting one */
  assert(!ctx_lst_isempty(&ctx_lst));

  ctx_t* ctx = ctx_lst_next(&ctx_lst, current_ctx);

  /* free all terminated contexts and keep looking for a NEWBORN or RUNNABLE context */
  /* will continue indefinitely if there is no NEWBORN or RUNNABLE context          */
  while((ctx->state == UNDEFINED) || (ctx->state == BLOCKED) || (ctx->state == TERMINATED))
  {
    if(ctx->state == TERMINATED)
    {
      ctx_t* terminated_ctx = ctx;
      ctx = ctx_lst_next(&ctx_lst, terminated_ctx);
      free_context(terminated_ctx);
    }

    else
      ctx = ctx_lst_next(&ctx_lst, ctx);
  }

  /* switch to the context found */
  switch_to(ctx);
}






void sem_init(sem_t* s, int c)
{
  s->counter = c;
}



void sem_down(sem_t* s)
{
  __asm volatile("cli");

  s->counter--;

  /* if all the tokens have been used */
  if(s->counter <= 0)
  {
    /* block the current context */
    current_ctx->state = BLOCKED;

    /* get the context next to the current context in the list of contexts */
    ctx_t* ctx = ctx_lst_next(&ctx_lst, current_ctx);
    
    /* remove the current context from the list of contexts and put it in the semaphore's list of blocked contexts */
    ctx_lst_remove(&ctx_lst, current_ctx);
    ctx_lst_insert(&s->blocked_ctx_lst, current_ctx);
    
    /* switch to the next context of the list */
    switch_to(ctx);
  }

  __asm volatile("sti");
}



void sem_up(sem_t* s)
{
  __asm volatile("cli");

  s->counter++;

  /* if a token is free */
  if(s->counter <= 1)
  {
    /* get the next context in the list of contexts */
    ctx_t* ctx = ctx_lst_next(&s->blocked_ctx_lst, NULL);

    /* make the context RUNNABLE */
    ctx->state = RUNNABLE;
    
    /* remove the context from the semaphore's list of blocked contexts and put it in the list of contexts */
    ctx_lst_remove(&s->blocked_ctx_lst, ctx);
    ctx_lst_insert(&ctx_lst, ctx);
  }

  __asm volatile("sti");
}