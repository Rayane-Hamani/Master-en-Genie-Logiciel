#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "drive.h"
#include "mbr.h"
#include "superblock.h"



struct superblock superblock;
unsigned int current_volume;



void init_volume(unsigned int vol)
{
    struct free_block free_block;
    unsigned char buffer[HDA_SECTORSIZE];

    current_volume = vol;

    srand(time(NULL));
    
    /* Initialize the superblock */

    superblock.serial_number    = rand();
    sprintf(superblock.name, "volume %d", superblock.serial_number);
    superblock.magic            = MAGIC;
    superblock.root_block       = 0;
    superblock.first_free_block = 1;
    superblock.nb_free_blocks   = mbr.volumes[current_volume].size - 1;

    memcpy(buffer, &superblock, sizeof(struct superblock));
    write_bloc(current_volume, 0, buffer);

    /* Initialize the first free block */

    free_block.size = superblock.nb_free_blocks;
    free_block.next = 0;

    memset(buffer, 0, HDA_SECTORSIZE);
    memcpy(buffer, &free_block, sizeof(struct free_block));
    write_bloc(current_volume, superblock.first_free_block, buffer);
}

int load_super(unsigned int vol)
{
    unsigned char buffer[HDA_SECTORSIZE];

    current_volume = vol;

    read_bloc(current_volume, 0, buffer);

    memcpy(&superblock, buffer, sizeof(struct superblock));

    /*
    if(superblock.magic != mbr.magic)
    {
        init_volume(current_volume);
    }
    */

    return superblock.magic == MAGIC;
}

void save_super()
{
    unsigned char buffer[HDA_SECTORSIZE];
    memcpy(buffer, &superblock, sizeof(struct superblock));
    write_bloc(current_volume, 0, buffer);
}

unsigned int new_bloc()
{
    struct free_block free_block;
    unsigned char buffer[HDA_SECTORSIZE];

    if(superblock.nb_free_blocks == 0)
        return EXIT_FAILURE;
    
    read_bloc(current_volume, superblock.first_free_block, buffer);
    memcpy(&free_block, buffer, sizeof(struct free_block));

    if(free_block.size > 1)
    {
        superblock.first_free_block++;
        free_block.size--;
        memcpy(buffer, &free_block, sizeof(struct free_block));
        write_bloc(current_volume, superblock.first_free_block, buffer);
    }
    else
        superblock.first_free_block = free_block.next;
    
    superblock.nb_free_blocks--;
    save_super();

    return EXIT_SUCCESS;
}

void free_bloc(unsigned int bloc)
{
    struct free_block free_block;
    unsigned char buffer[HDA_SECTORSIZE];

    free_block.size = 1;
    free_block.next = superblock.first_free_block;

    superblock.first_free_block = bloc;
    superblock.nb_free_blocks++;

    memcpy(buffer, &free_block, sizeof(struct free_block));
    write_bloc(current_volume, bloc, buffer);
}