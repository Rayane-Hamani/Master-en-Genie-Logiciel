// static void ppage_of_ovpage(int process, unsigned vpage)
// IRQVECTOR[MMUR_IRQ] = 

// page physique 0 : IRQVECTOR

// page physique -> processus, page virtuelle
// 1 -> 1, 0
// 2 -> 2, 0
// 3 -> 1, 1
// 4 -> 2, 1
// 5 -> 1, 2
// 6 -> 2, 3

// 1 -> 1, 0
// 2 -> 1, 1
// 3 -> 1, 2
// 4 -> 2, 0
// 5 -> 2, 1
// 6 -> 2, 2

// le bit de poids fort ne peut pas Ãªtre 0 car appartient au noyau

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "exercice3.h"
#include "include/hardware.h"



int current_process;



int ppage_of_vpage(int process, unsigned vpage)
{
    if((vpage > ((int) FIRST_VM_ADDRESS)) && (vpage <= ((int) LAST_VM_ADDRESS)))
        for(int i=0; i<PM_PAGES; i++)
            if(pmapping[i] == (vpage >> 12))
                if((process==0 && i<127) || (process==1 && i>=127))
                    return (pmapping[i] << 12) + (vpage & 0xFFF);

    return -1;
}



int sum(void *ptr) 
{
    int i;
    int sum = 0;
    
    for(i = 0; i < PM_SIZE/2 ; i++)
        sum += ((char*)ptr)[i];
    return sum;
}



void switch_to_process0(void) 
{
    current_process = 0;
    _out(MMU_CMD, MMU_RESET);
}

void switch_to_process1(void) 
{
    current_process = 1;
    _out(MMU_CMD, MMU_RESET);
}



int main() 
{
    void *ptr;
    int res;

    assert(init_hardware("etc/hardware.ini") != 0);
    IRQVECTOR[SYSCALL_SWTCH_0] = switch_to_process0;
    IRQVECTOR[SYSCALL_SWTCH_1] = switch_to_process1;
    _mask(0x1001);

    ptr = virtual_memory;

    _int(SYSCALL_SWTCH_0);
    memset(ptr, 1, PM_SIZE/2);
    _int(SYSCALL_SWTCH_1);
    memset(ptr, 3, PM_SIZE/2);

    _int(SYSCALL_SWTCH_0);
    res = sum(ptr);
    printf("Resultat du processus 0 : %d\n",res);
    _int(SYSCALL_SWTCH_1);
    res = sum(ptr);
    printf("Resultat processus 1 : %d\n",res);
}
